=== Estructura de directorios y archivos ===
├── Dockerfile
├── README.md
├── go.mod
├── api
│   ├── server.go
├── docker-compose.yml
├── script.sh
├── fix.sh
├── go.sum
├── generateProxyProto.sh
├── internal
│   ├── proxy
│   │   ├── proxy.go
│   ├── scraper
│   │   ├── scraper.go
│   ├── config
│   │   ├── config.go
│   │   ├── sessions.go
├── cmd
│   ├── main.go

=== Contenido de archivos ===
----- [Archivo: api/server.go] -----
// api/server.go
package api

import (
	"context"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net"
	"net/http"
	"net/url"
	pb "proxy-api/fetch"
	"proxy-api/internal/config"
	"proxy-api/internal/proxy"
	"proxy-api/internal/scraper"
	"strings"
	"sync"
	"time"

	"google.golang.org/grpc"
)

var (
	validProxies map[string][]string
	userAgents   []string
)

type server struct {
	pb.UnimplementedProxyServiceServer
	successfulProxies map[string]*http.Client
	mtx               sync.RWMutex
}

var errorMap = map[string]struct{}{
	"context deadline exceeded (Client.Timeout or context cancellation while reading body)": {},
	"EOF":                       {},
	"read tcp":                  {},
	"connection":                {},
	"Timeout":                   {},
	"Forbidden":                 {},
	"(Client.Timeout":           {},
	"Internal Server Error":     {},
	"Bad Gateway":               {},
	"Service Unavailable":       {},
	"Gateway Timeout":           {},
	"Too many open connections": {},
	"unconfigured cipher suite": {},
	"ClientConn.Close":          {},
	"GOAWAY":                    {},
	"proxyconnect tcp:":         {},
	"Temporary Redirect":        {},
	"Internal Privoxy Error":    {},
	"certificate":               {},
	"bad record MAC":            {},
	"lookup":                    {},
}

func isTimeoutError(err error) bool {
	if urlErr, ok := err.(*url.Error); ok && urlErr.Timeout() {
		return true
	}

	for errMsg := range errorMap {
		if strings.Contains(err.Error(), errMsg) || err.Error() == errMsg {
			return true
		}
	}

	return false
}

var nilMap = map[string]struct{}{
	"<strong>Error:</strong>": {},
	"Marshal":                 {},
	"error while marshaling: proto: Marshal called with nilh": {},
	"Servicio no": {},
	"GOAWAY":      {},
	`http2: server sent GOAWAY and closed the connection;`:                      {},
	`{"code":110,"message":"Sport API error","name":"ServiceUnavailableError"}`: {},
	"http2:":          {},
	"temporary error": {},
}

func IsNilContent(content string) bool {
	for errMsg := range nilMap {
		if strings.Contains(content, errMsg) || content == errMsg {
			return true
		}
	}

	return false
}

func (s *server) getHTTPClient(proxyAddr string, redirect bool, session string) (*http.Client, error) {
	s.mtx.RLock()
	client, ok := s.successfulProxies[proxyAddr]
	s.mtx.RUnlock()

	if ok {
		return client, nil
	}

	if proxyAddr == "default" {
		return http.DefaultClient, nil
	}

	proxyURL, _ := url.Parse(proxyAddr)
	client = &http.Client{
		Transport: &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
		},
		Timeout: time.Duration(config.ProxySessions[session].Timeout) * time.Millisecond,
	}

	if !redirect {
		client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		}
	} else {
		client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
			return nil
		}
	}

	s.mtx.Lock()
	s.successfulProxies[proxyAddr] = client
	s.mtx.Unlock()

	return client, nil
}

func (s *server) removeSuccesfulProxy(proxyAddr string) {
	s.mtx.Lock()
	delete(s.successfulProxies, proxyAddr)
	s.mtx.Unlock()
}

// GetRandomProxy - Nuevo método para obtener un proxy aleatorio de una sesión específica
func (s *server) GetRandomProxy(ctx context.Context, req *pb.ProxyRequest) (*pb.ProxyResponse, error) {
	if req.Session == "" {
		return nil, fmt.Errorf("session cannot be empty")
	}

	// Verificar si la sesión existe en la configuración
	if _, exists := config.ProxySessions[req.Session]; !exists {
		return nil, fmt.Errorf("session '%s' not found in configuration", req.Session)
	}

	// Verificar si hay proxies válidos para esta sesión
	proxies, exists := validProxies[req.Session]
	if !exists || len(proxies) == 0 {
		return &pb.ProxyResponse{
			Proxy:   "",
			Success: false,
			Message: fmt.Sprintf("no valid proxies available for session '%s'", req.Session),
		}, nil
	}

	// Seleccionar un proxy aleatorio
	randomIndex := rand.Intn(len(proxies))
	selectedProxy := proxies[randomIndex]

	log.Printf("Selected random proxy for session '%s': %s", req.Session, selectedProxy)

	return &pb.ProxyResponse{
		Proxy:   selectedProxy,
		Success: true,
		Message: fmt.Sprintf("proxy selected successfully for session '%s'", req.Session),
	}, nil
}

// GetProxyStats - Método adicional para obtener estadísticas de proxies por sesión
func (s *server) GetProxyStats(ctx context.Context, req *pb.StatsRequest) (*pb.StatsResponse, error) {
	stats := make(map[string]int32)
	
	for session, proxies := range validProxies {
		stats[session] = int32(len(proxies))
	}

	return &pb.StatsResponse{
		ProxyCountBySession: stats,
		TotalValidProxies:   int32(getTotalProxyCount()),
	}, nil
}

func getTotalProxyCount() int {
	total := 0
	for _, proxies := range validProxies {
		total += len(proxies)
	}
	return total
}

// WITHOUT PROXIES
func (s *server) Fetch(ctx context.Context, req *pb.Request, userAgent string, redirect bool) (*pb.Response, error) {
	client, err := s.getHTTPClient("default", redirect, req.Session)
	if err != nil {
		return nil, err
	}

	reqObj, err := http.NewRequestWithContext(ctx, "GET", req.Url, nil)
	if err != nil {
		return nil, err
	}

	reqObj.Header.Set("User-Agent", userAgent)
	for k, v := range config.GetHeadersFromSession(req.Session) {
		reqObj.Header.Set(k, v)
	}

	resp, err := client.Do(reqObj)
	if err != nil {
		// Retry if there is a timeout error.
		if ctx.Err() == context.DeadlineExceeded || isTimeoutError(err) {
			log.Println("Retry due to", err)
			return s.Fetch(ctx, req, userAgent, redirect)
		}

		return nil, err
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	log.Printf("User-Agent: %s, Status: %d, URL: %s\n", userAgent, resp.StatusCode, req.Url)
	return &pb.Response{Content: bodyBytes}, nil
}

func (s *server) useProxyToFetch(ctx context.Context, req *pb.Request, proxyAddr string, userAgent string, redirect bool, contentChan chan []byte, errorChan chan error) {
	client, err := s.getHTTPClient(proxyAddr, redirect, req.Session)
	if err != nil {
		errorChan <- err
		return
	}

	reqObj, err := http.NewRequestWithContext(ctx, "GET", req.Url, nil)
	if err != nil {
		errorChan <- err
		return
	}

	reqObj.Header.Set("User-Agent", userAgent)
	for k, v := range config.GetHeadersFromSession(req.Session) {
		reqObj.Header.Set(k, v)
	}

	resp, err := client.Do(reqObj)
	if err != nil {
		s.removeSuccesfulProxy(proxyAddr) // remove the proxy from successfulProxies
		errorChan <- err
		return
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		errorChan <- err
		return
	}

	log.Printf("Proxy: %s, User-Agent: %s, Status: %d, URL: %s", proxyAddr, userAgent, resp.StatusCode, req.Url)
	contentChan <- bodyBytes
}

func (s *server) FetchContent(ctx context.Context, req *pb.Request) (*pb.Response, error) {
	if req.Session == "" || validProxies[req.Session] == nil {
		return nil, fmt.Errorf("invalid session")
	}

	var redirect bool
	if req.Redirect {
		redirect = req.Redirect
	} else {
		redirect = false
	}

	selectedUserAgent := userAgents[rand.Intn(len(userAgents))]

	if req.Proxy {
		contentChan := make(chan []byte)
		errorChan := make(chan error)

		// Primero se utilizan los successfulProxies
		s.mtx.RLock()
		for proxyAddr := range s.successfulProxies {
			go s.useProxyToFetch(ctx, req, "http://"+proxyAddr, selectedUserAgent, redirect, contentChan, errorChan)
		}
		s.mtx.RUnlock()

		// Si falla, utiliza los validProxies
		if len(contentChan) == 0 {
			for _, proxyAddr := range validProxies[req.Session] {
				go s.useProxyToFetch(ctx, req, "http://"+proxyAddr, selectedUserAgent, redirect, contentChan, errorChan)
			}
		}

		for range validProxies[req.Session] {
			select {
			case content := <-contentChan:
				return &pb.Response{Content: content}, nil
			case <-errorChan:
				continue
			}
		}

		return s.Fetch(ctx, req, selectedUserAgent, redirect)
	}

	return s.Fetch(ctx, req, selectedUserAgent, redirect)
}

func UpdateValidProxies(proxies map[string][]string) {
	validProxies = proxies
}

func StartGRPCServer() {
	validProxies = proxy.GetValidProxies()
	userAgents = scraper.ScrapeUserAgents()

	log.Println("Iniciando servidor gRPC")
	lis, err := net.Listen("tcp", ":5000")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	maxSize := 5 * 1024 * 1024
	grpcServer := grpc.NewServer(
		grpc.MaxRecvMsgSize(maxSize), // Tamaño máximo de mensaje recibido.
		grpc.MaxSendMsgSize(maxSize), // Tamaño máximo de mensaje enviado.
	)
	pb.RegisterProxyServiceServer(grpcServer, &server{successfulProxies: make(map[string]*http.Client)})
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
----- [Archivo: cmd/main.go] -----
package main

import (
	"fmt"
	"proxy-api/api"
	"proxy-api/internal/config"
	"proxy-api/internal/proxy"
	"time"
)

func main() {
	// Iniciar el servidor gRPC
	go api.StartGRPCServer()

	// Refrescar proxies al inicio
	go reloadProxiesInBackground()

	// Mantener la aplicación en ejecución
	select {}
}

func reloadProxiesInBackground() {
	for {
		time.Sleep(config.UpdateTime * time.Minute)

		newProxyMap := proxy.GetValidProxies()
		fmt.Printf("Proxies válidos refrescados: %d\n", len(newProxyMap))

		// Update the valid proxies in the server
		api.UpdateValidProxies(newProxyMap)
	}
}

----- [Archivo: docker-compose.yml] -----
version: "3.8"

services:
  api:
    build: .
    container_name: proxy_server
    ports:
      - "5000:5000"
    restart: always
    networks:
      - proxy_network

networks:
  proxy_network:
    driver: bridge
    name: proxy_network
    
----- [Archivo: Dockerfile] -----
# Usa una imagen de Go como base
FROM golang AS builder

# Configura las variables de entorno
ENV GO111MODULE=on \
    CGO_ENABLED=0 \
    GOOS=linux \
    GOARCH=amd64

# Crea un directorio de trabajo dentro del contenedor
WORKDIR /build

# Copia los archivos del proyecto al directorio de trabajo
COPY . .

# Compila la aplicación
RUN go build -o main ./cmd/main.go

# Empieza a construir la imagen final
FROM alpine:latest

# Instala las dependencias necesarias
RUN apk --no-cache add ca-certificates

# Copia el binario compilado desde la etapa anterior
COPY --from=builder /build/main /app/main

# Establece el directorio de trabajo
WORKDIR /app

# Expone el puerto en el que la aplicación escucha
EXPOSE 5000

# Ejecuta la aplicación cuando el contenedor se inicia
CMD ["./main"]
----- [Archivo: fix.sh] -----
#!/usr/bin/env bash

# Script para resolver problemas de compatibilidad con gRPC
set -e

echo "=== Solucionando problemas de compatibilidad gRPC ==="

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Función para imprimir mensajes coloreados
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 1. Verificar que Go está instalado
if ! command -v go &> /dev/null; then
    print_error "Go no está instalado. Por favor instálalo desde https://golang.org/"
    exit 1
fi

print_status "Go versión: $(go version)"

# 2. Limpiar módulos y caché
print_status "Limpiando caché de módulos Go..."
go clean -modcache
go mod tidy

# 3. Actualizar dependencias
print_status "Actualizando dependencias..."
go get -u google.golang.org/grpc@latest
go get -u google.golang.org/protobuf@latest
go mod tidy

# 4. Instalar/actualizar herramientas de protoc
print_status "Instalando herramientas de Protocol Buffers..."

# Verificar si protoc está instalado
if ! command -v protoc &> /dev/null; then
    print_error "protoc no está instalado."
    echo "Por favor instálalo:"
    echo "  - Ubuntu/Debian: sudo apt install protobuf-compiler"
    echo "  - macOS: brew install protobuf"
    echo "  - Windows: Descarga desde https://github.com/protocolbuffers/protobuf/releases"
    exit 1
fi

print_status "protoc versión: $(protoc --version)"

# Instalar plugins de Go para protoc
print_status "Instalando plugins de protoc para Go..."
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

# Verificar que los plugins están en el PATH
if ! command -v protoc-gen-go &> /dev/null; then
    print_warning "protoc-gen-go no está en el PATH"
    echo "Asegúrate de que \$GOPATH/bin está en tu PATH:"
    echo "export PATH=\$PATH:\$(go env GOPATH)/bin"
fi

if ! command -v protoc-gen-go-grpc &> /dev/null; then
    print_warning "protoc-gen-go-grpc no está en el PATH"
    echo "Asegúrate de que \$GOPATH/bin está en tu PATH:"
    echo "export PATH=\$PATH:\$(go env GOPATH)/bin"
fi

# 5. Crear directorio fetch si no existe
mkdir -p fetch

# 6. Crear archivo proto actualizado
print_status "Creando archivo proto actualizado..."
cat > fetch/proxy.proto << 'EOF'
syntax = "proto3";

package fetch;

option go_package = "proxy-api/fetch";

// Servicio principal de proxy
service ProxyService {
    // Método existente para obtener contenido
    rpc FetchContent(Request) returns (Response);
    
    // Nuevo método para obtener un proxy aleatorio
    rpc GetRandomProxy(ProxyRequest) returns (ProxyResponse);
    
    // Método adicional para obtener estadísticas de proxies
    rpc GetProxyStats(StatsRequest) returns (StatsResponse);
}

// Mensaje de solicitud existente
message Request {
    string url = 1;
    string session = 2;
    bool proxy = 3;
    bool redirect = 4;
}

// Mensaje de respuesta existente
message Response {
    bytes content = 1;
}

// Nuevo mensaje para solicitar un proxy aleatorio
message ProxyRequest {
    string session = 1; // Sesión para la cual obtener el proxy
}

// Nuevo mensaje de respuesta para proxy aleatorio
message ProxyResponse {
    string proxy = 1;   // Dirección del proxy (ip:port)
    bool success = 2;   // Indica si la operación fue exitosa
    string message = 3; // Mensaje descriptivo del resultado
}

// Mensaje para solicitar estadísticas
message StatsRequest {
    // Vacío por ahora, podría expandirse en el futuro
}

// Mensaje de respuesta con estadísticas
message StatsResponse {
    map<string, int32> proxy_count_by_session = 1; // Cantidad de proxies por sesión
    int32 total_valid_proxies = 2;                 // Total de proxies válidos
}
EOF

# 7. Eliminar archivos proto generados anteriormente
print_status "Eliminando archivos proto generados anteriormente..."
rm -f fetch/*.pb.go

# 8. Generar nuevos archivos proto
print_status "Generando archivos proto..."
protoc \
    --proto_path=fetch \
    --go_out=fetch \
    --go_opt=paths=source_relative \
    --go-grpc_out=fetch \
    --go-grpc_opt=paths=source_relative \
    fetch/proxy.proto

# 9. Verificar que los archivos se generaron correctamente
if [ -f "fetch/proxy.pb.go" ] && [ -f "fetch/proxy_grpc.pb.go" ]; then
    print_status "✅ Archivos proto generados exitosamente"
else
    print_error "❌ Error generando archivos proto"
    exit 1
fi

# 10. Intentar compilar el proyecto
print_status "Verificando compilación del proyecto..."
if go build ./cmd/main.go; then
    print_status "✅ Proyecto compilado exitosamente"
    rm -f main # Limpiar binario de prueba
else
    print_error "❌ Error compilando el proyecto"
    echo "Revisa los errores anteriores e intenta de nuevo"
    exit 1
fi

# 11. Mostrar información de las dependencias
print_status "Información de dependencias actuales:"
go list -m all | grep -E "(grpc|protobuf)"

echo ""
print_status "🎉 ¡Problema resuelto! El proyecto debería compilar correctamente ahora."
echo ""
echo "Próximos pasos:"
echo "1. go build ./cmd/main.go"
echo "2. ./main"
echo "3. go run client/main.go (en otra terminal)"
----- [Archivo: generateProxyProto.sh] -----
#!/usr/bin/env bash

# Script para generar archivos gRPC desde el archivo proto
# Asegúrate de tener instalados:
# - protoc (Protocol Buffers compiler)
# - protoc-gen-go (Go plugin para protoc)
# - protoc-gen-go-grpc (gRPC Go plugin)

set -e

echo "=== Generando archivos gRPC desde proxy_service.proto ==="

# Directorio donde está el archivo proto
PROTO_DIR="fetch/"
# Directorio de salida para los archivos generados
OUT_DIR="fetch/"

# Crear directorio de salida si no existe
mkdir -p "$OUT_DIR"

# Verificar que existe el archivo proto
if [ ! -f "$PROTO_DIR/proxy_service.proto" ]; then
    echo "Error: No se encontró el archivo proxy_service.proto en $PROTO_DIR"
    echo "Por favor asegúrate de que el archivo proto existe."
    exit 1
fi

# Verificar que protoc está instalado
if ! command -v protoc &> /dev/null; then
    echo "Error: protoc no está instalado."
    echo "Instálalo desde: https://grpc.io/docs/protoc-installation/"
    exit 1
fi

# Verificar que los plugins de Go están instalados
if ! command -v protoc-gen-go &> /dev/null; then
    echo "Error: protoc-gen-go no está instalado."
    echo "Instálalo con: go install google.golang.org/protobuf/cmd/protoc-gen-go@latest"
    exit 1
fi

if ! command -v protoc-gen-go-grpc &> /dev/null; then
    echo "Error: protoc-gen-go-grpc no está instalado."
    echo "Instálalo con: go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest"
    exit 1
fi

echo "Generando archivos Go desde proxy_service.proto..."

# Generar archivos Go
protoc \
    --proto_path="$PROTO_DIR" \
    --go_out="$OUT_DIR" \
    --go_opt=paths=source_relative \
    --go-grpc_out="$OUT_DIR" \
    --go-grpc_opt=paths=source_relative \
    "$PROTO_DIR/proxy_service.proto"

echo "✅ Archivos Go generados exitosamente en $OUT_DIR"

# Opcional: Generar para otros lenguajes
read -p "¿Quieres generar también archivos para Python? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    PYTHON_OUT="./generated/python"
    mkdir -p "$PYTHON_OUT"
    
    if command -v python3 &> /dev/null && python3 -c "import grpc_tools" &> /dev/null; then
        echo "Generando archivos Python..."
        python3 -m grpc_tools.protoc \
            --proto_path="$PROTO_DIR" \
            --python_out="$PYTHON_OUT" \
            --grpc_python_out="$PYTHON_OUT" \
            "$PROTO_DIR/proxy_service.proto"
        echo "✅ Archivos Python generados en $PYTHON_OUT"
    else
        echo "❌ Python3 o grpc_tools no están disponibles"
        echo "Instala con: pip install grpcio-tools"
    fi
fi

read -p "¿Quieres generar también archivos para JavaScript/TypeScript? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    JS_OUT="./generated/javascript"
    mkdir -p "$JS_OUT"
    
    if command -v npm &> /dev/null; then
        echo "Generando archivos JavaScript..."
        protoc \
            --proto_path="$PROTO_DIR" \
            --js_out=import_style=commonjs,binary:"$JS_OUT" \
            --grpc-web_out=import_style=commonjs,mode=grpcwebtext:"$JS_OUT" \
            "$PROTO_DIR/proxy_service.proto"
        echo "✅ Archivos JavaScript generados en $JS_OUT"
    else
        echo "❌ npm no está disponible"
    fi
fi

echo ""
echo "=== Generación completada ==="
echo "Archivos principales generados:"
echo "  - $OUT_DIR/proxy.pb.go (mensajes Protocol Buffers)"
echo "  - $OUT_DIR/proxy_grpc.pb.go (servicio gRPC)"
echo ""
echo "Para usar estos archivos en tu proyecto Go:"
echo "  import fetch \"proxy-api/fetch\""
echo ""
echo "Para recompilar el proyecto:"
echo "  go build ./cmd/main.go"
----- [Archivo: go.mod] -----
module proxy-api

go 1.23.0

toolchain go1.23.12

require (
	google.golang.org/grpc v1.74.2
	google.golang.org/protobuf v1.36.7
)

require (
	golang.org/x/net v0.42.0 // indirect
	golang.org/x/sys v0.35.0 // indirect
	golang.org/x/text v0.28.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b // indirect
)

----- [Archivo: go.sum] -----
github.com/go-logr/logr v1.4.3 h1:CjnDlHq8ikf6E492q6eKboGOC0T8CDaOvkHCIg8idEI=
github.com/go-logr/logr v1.4.3/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
go.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJySYA=
go.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=
go.opentelemetry.io/otel v1.36.0 h1:UumtzIklRBY6cI/lllNZlALOF5nNIzJVb16APdvgTXg=
go.opentelemetry.io/otel v1.36.0/go.mod h1:/TcFMXYjyRNh8khOAO9ybYkqaDBb/70aVwkNML4pP8E=
go.opentelemetry.io/otel/metric v1.36.0 h1:MoWPKVhQvJ+eeXWHFBOPoBOi20jh6Iq2CcCREuTYufE=
go.opentelemetry.io/otel/metric v1.36.0/go.mod h1:zC7Ks+yeyJt4xig9DEw9kuUFe5C3zLbVjV2PzT6qzbs=
go.opentelemetry.io/otel/sdk v1.36.0 h1:b6SYIuLRs88ztox4EyrvRti80uXIFy+Sqzoh9kFULbs=
go.opentelemetry.io/otel/sdk v1.36.0/go.mod h1:+lC+mTgD+MUWfjJubi2vvXWcVxyr9rmlshZni72pXeY=
go.opentelemetry.io/otel/sdk/metric v1.36.0 h1:r0ntwwGosWGaa0CrSt8cuNuTcccMXERFwHX4dThiPis=
go.opentelemetry.io/otel/sdk/metric v1.36.0/go.mod h1:qTNOhFDfKRwX0yXOqJYegL5WRaW376QbB7P4Pb0qva4=
go.opentelemetry.io/otel/trace v1.36.0 h1:ahxWNuqZjpdiFAyrIoQ4GIiAIhxAunQR6MUoKrsNd4w=
go.opentelemetry.io/otel/trace v1.36.0/go.mod h1:gQ+OnDZzrybY4k4seLzPAWNwVBBVlF2szhehOBB/tGA=
golang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=
golang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=
golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=
golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/text v0.28.0 h1:rhazDwis8INMIwQ4tpjLDzUhx6RlXqZNPEM0huQojng=
golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b h1:zPKJod4w6F1+nRGDI9ubnXYhU9NSWoFAijkHkUXeTK8=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b/go.mod h1:qQ0YXyHHx3XkvlzUtpXDkS29lDSafHMZBAZDc03LQ3A=
google.golang.org/grpc v1.74.2 h1:WoosgB65DlWVC9FqI82dGsZhWFNBSLjQ84bjROOpMu4=
google.golang.org/grpc v1.74.2/go.mod h1:CtQ+BGjaAIXHs/5YS3i473GqwBBa1zGQNevxdeBEXrM=
google.golang.org/protobuf v1.36.7 h1:IgrO7UwFQGJdRNXH/sQux4R1Dj1WAKcLElzeeRaXV2A=
google.golang.org/protobuf v1.36.7/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=

----- [Archivo: internal/config/config.go] -----
package config

// Tamaño del chunk de proxies
const DefaultChunkSize = 20
const DefaultSessionTimeout = 2000 //ms
const UpdateTime = 30

----- [Archivo: internal/config/sessions.go] -----
package config

type ProxySession struct {
	Name    string
	URL     string
	Headers map[string]string
	Timeout int
}

var ProxySessions = map[string]ProxySession{
	/*"FlashScore": {
		Name: "FlashScore",
		URL:  "https://local-global.flashscore.ninja/2/x/feed/r_1_1",
		Headers: map[string]string{
			"Accept-Encoding":    "gzip, deflate, br",
			"Accept-Language":    "es-ES,es;q=0.9,en;q=0.8,zh-TW;q=0.7,zh;q=0.6,ja;q=0.5,zh-CN;q=0.4",
			"Origin":             "https://www.flashscore.es",
			"Referer":            "https://www.flashscore.es/",
			"Sec-Ch-Ua":          "'Google Chrome';v='117', 'Not;A=Brand';v='8', 'Chromium';v='117'",
			"Sec-Ch-Ua-Mobile":   "?0",
			"Sec-Ch-Ua-Platform": "'Windows'",
			"Sec-Fetch-Dest":     "empty",
			"Sec-Fetch-Mode":     "cors",
			"Sec-Fetch-Site":     "cross-site",
			"X-Fsign":            "SW9D1eZo",
		},
		Timeout: DefaultSessionTimeout,
	}, */
	"CoinMarketCap": {
		Name:    "CoinMarketCap",
		URL:     "https://coinmarketcap.com/es/",
		Headers: map[string]string{},
		Timeout: DefaultSessionTimeout,
	},
}

func GetHeadersFromSession(session string) map[string]string {
	return ProxySessions[session].Headers
}

----- [Archivo: internal/proxy/proxy.go] -----
package proxy

import (
	"log"
	"net/http"
	"net/url"
	"proxy-api/internal/config"
	"proxy-api/internal/scraper"
	"sync"
	"time"
)

// Tamaño del chunk, idealmente esto debería venir de un archivo de configuración
const ChunkSize = config.DefaultChunkSize

// ValidProxies almacena los proxies válidos, con locking para acceso seguro
var (
	ValidProxies = make(map[string][]string)
	mutex        = &sync.Mutex{}
)

// Procesar un solo test de proxy
func RunProxyTest(cfg config.ProxySession, proxy string) {
	proxyURL, err := url.Parse("http://" + proxy)
	if err != nil {
		log.Printf("Error al parsear el proxy %s: %v", proxy, err)
		return
	}

	httpClient := &http.Client{
		Transport: &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
		},
		Timeout: time.Duration(cfg.Timeout) * time.Millisecond,
	}

	request, err := http.NewRequest("GET", cfg.URL, nil)
	if err != nil {
		log.Printf("Error al crear la solicitud: %v", err)
		return
	}

	for headerName, headerValue := range cfg.Headers {
		request.Header.Set(headerName, headerValue)
	}

	request.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36")

	resp, err := httpClient.Do(request)
	if err != nil || (resp != nil && resp.StatusCode != 200) {
		log.Printf("Proxy %s no válido para %s", proxy, cfg.Name)
		if resp != nil {
			resp.Body.Close()
		}
		return
	}

	mutex.Lock()
	ValidProxies[cfg.Name] = append(ValidProxies[cfg.Name], proxy)
	mutex.Unlock()

	if resp != nil {
		resp.Body.Close()
	}
}

// Procesar todos los tests en un proxy
func runAllTests(proxy string) {
	var wg sync.WaitGroup
	wg.Add(len(config.ProxySessions))

	for _, test := range config.ProxySessions {
		go func(test config.ProxySession) {
			defer wg.Done()
			RunProxyTest(test, proxy)
		}(test)
	}

	wg.Wait()
}

// Divide los proxies en chunks más manejables
func chunkProxies(proxies []string) [][]string {
	var chunks [][]string
	for i := 0; i < len(proxies); i += ChunkSize {
		end := i + ChunkSize
		if end > len(proxies) {
			end = len(proxies)
		}
		chunks = append(chunks, proxies[i:end])
	}
	return chunks
}

// ValidateProxies realiza la validación de la lista de proxies
func GetValidProxies() map[string][]string {
	proxies := scraper.ScrapeProxies()
	chunks := chunkProxies(proxies)
	var wg sync.WaitGroup
	var progressMutex sync.Mutex
	chunksProcessed := 0

	for _, chunk := range chunks {
		wg.Add(1)
		go func(chunk []string) {
			defer wg.Done()
			for _, proxy := range chunk {
				runAllTests(proxy)
			}

			progressMutex.Lock()
			chunksProcessed++
			log.Printf("Progreso: %d/%d chunks procesados.", chunksProcessed, len(chunks))
			progressMutex.Unlock()

		}(chunk)
	}

	wg.Wait()

	mutex.Lock()
	defer mutex.Unlock()
	for site, proxies := range ValidProxies {
		log.Printf("Sitio web: %s | Proxies: %v", site, len(proxies))
	}

	return ValidProxies
}

----- [Archivo: internal/scraper/scraper.go] -----
package scraper

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

type Scraper struct {
	urls     []string
	dataType string
}

func NewScraper(urls []string, dataType string) *Scraper {
	return &Scraper{
		urls:     urls,
		dataType: dataType,
	}
}

func (s *Scraper) Scrape(ctx context.Context) []string {
	resultChan := make(chan []string)
	errChan := make(chan error)

	for _, url := range s.urls {
		go s.fetchData(ctx, url, resultChan, errChan)
	}

	timeout := time.After(25 * time.Second)
	var results []string
	for i := 0; i < len(s.urls); i++ {
		select {
		case res := <-resultChan:
			results = append(results, res...)
		case err := <-errChan:
			fmt.Printf("Error scraping %s data: %s\n", s.dataType, err)
		case <-timeout:
			fmt.Println("Scraping timed out.")
			return results
		}
	}
	return results
}

func (s *Scraper) fetchData(ctx context.Context, url string, resultChan chan []string, errChan chan error) {
	fmt.Printf("Obteniendo %s de %s...\n", s.dataType, url)

	req, _ := http.NewRequest(http.MethodGet, url, nil)
	resp, err := http.DefaultClient.Do(req.WithContext(ctx))
	if err != nil {
		errChan <- err
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		errChan <- err
		return
	}

	lines := strings.Split(string(body), "\n")
	var validLines []string
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.Count(trimmed, ":") > 1 {
			trimmed = strings.Split(trimmed, ":")[0] + ":" + strings.Split(trimmed, ":")[1]
		}
		if trimmed != "" || (strings.Contains(url, "user-agents") && (!strings.Contains(trimmed, "Android") &&
			!strings.Contains(trimmed, "iPhone") &&
			!strings.Contains(trimmed, "iPad") &&
			!strings.Contains(trimmed, "compatible;"))) {

			validLines = append(validLines, trimmed)
		}
	}
	resultChan <- validLines
}

func ScrapeProxies() []string {
	urls := []string{
		// "https://raw.githubusercontent.com/proxifly/free-proxy-list/main/proxies/protocols/http/data.txt",
		// "https://raw.githubusercontent.com/proxifly/free-proxy-list/refs/heads/main/proxies/all/data.txt",
		"https://raw.githubusercontent.com/officialputuid/KangProxy/refs/heads/KangProxy/https/https.txt",
		"https://raw.githubusercontent.com/vakhov/fresh-proxy-list/refs/heads/master/https.txt",
		// "https://raw.githubusercontent.com/prxchk/proxy-list/main/http.txt",
		// "https://raw.githubusercontent.com/proxifly/free-proxy-list/main/proxies/protocols/http/data.txt",
		// "https://raw.githubusercontent.com/vakhov/fresh-proxy-list/master/http.txt",
		// "https://raw.githubusercontent.com/MuRongPIG/Proxy-Master/main/http.txt",
		// "https://raw.githubusercontent.com/ProxyScraper/ProxyScraper/main/http.txt",
	}
	scraper := NewScraper(urls, "proxies")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	return scraper.Scrape(ctx)
}

func ScrapeUserAgents() []string {
	urls := []string{
		"https://gist.githubusercontent.com/pzb/b4b6f57144aea7827ae4/raw/cf847b76a142955b1410c8bcef3aabe221a63db1/user-agents.txt",
	}
	scraper := NewScraper(urls, "user-agents")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Número máximo de intentos
	maxRetries := 3

	for attempt := 1; attempt <= maxRetries; attempt++ {
		result := scraper.Scrape(ctx)
		if len(result) > 0 {
			// Si la operación tiene éxito, retornar los datos
			return result
		}

		// Si la operación falla, esperar un momento antes de volver a intentar
		fmt.Printf("Intento %d fallido. Reintentando...\n", attempt)
		scraper = NewScraper(urls, "user-agents")
		time.Sleep(2 * time.Second)
	}

	// Si todos los intentos fallan, retornar una lista vacía o manejar el error de otra manera.
	return []string{}
}

----- [Archivo: README.md] -----
# Instrucciones Avanzadas para el Uso del Proyecto Proxy-API

## Montaje de la Imagen Docker en Segundo Plano

Además del uso de `docker-compose`, puedes construir y ejecutar la imagen Docker manualmente.

### Construir la Imagen con Docker Build

1. **Construye la imagen Docker:**
   ```sh
   docker build -t proxy-api .
   ```

   Esto creará una imagen Docker llamada `proxy-api` utilizando el `Dockerfile` presente en el proyecto.

2. **Ejecutar la imagen en segundo plano:**
   ```sh
   docker run -d -p 5000:5000 --name proxy_server proxy-api
   ```

   Este comando ejecutará un contenedor basado en la imagen `proxy-api`, exponiendo el puerto 5000 y ejecutándose en segundo plano.

## Uso de los Archivos Proto en Otros Proyectos

Para generar los archivos necesarios para utilizar el servicio gRPC en otros proyectos:

1. **Ejecuta el script `generateProxyProto.sh`:**
   ```sh
   ./generateProxyProto.sh
   ```

   Esto generará los archivos necesarios en los lenguajes especificados (por ejemplo, Go, Python, etc.) a partir del archivo `proto`.

2. **Importa los archivos generados en tu proyecto cliente:**
   Utiliza estos archivos en tu proyecto cliente para interactuar con el servicio gRPC del Proxy-API.

## Sesiones y su Uso

Las sesiones en `config.ProxySessions` permiten especificar configuraciones particulares para diferentes destinos web. Cada sesión define un conjunto de encabezados HTTP, una URL y un tiempo de espera. Estas sesiones permiten adaptar las solicitudes a las particularidades de cada recurso web, como diferentes mecanismos de autenticación o requerimientos de encabezados específicos.

### Ejemplo de Sesiones

```go
var ProxySessions = map[string]ProxySession{
	"GoogleTranslateAPI": {
		Name:    "GoogleTranslateAPI",
		URL:     "https://translate.googleapis.com/translate_a/single...",
		Headers: map[string]string{},
		Timeout: DefaultSessionTimeout,
	},
	"GoogleTranslateClient": {
		Name:    "GoogleTranslateClient",
		URL:     "https://clients5.google.com/translate_a/t...",
		Headers: map[string]string{},
		Timeout: DefaultSessionTimeout,
	},
}
```

### Uso en el Servicio gRPC

Al realizar una solicitud a través del servicio `FetchContent` de gRPC, puedes especificar una de estas sesiones. El servidor Proxy-API utilizará la configuración de la sesión elegida para personalizar la solicitud HTTP.

#### Ejemplo de Uso de Sesiones en una Solicitud gRPC

```proto
message Request {
    string url = 1; // URL a acceder
    string session = 2; // Nombre de la sesión a utilizar
    bool proxy = 3; // Indica si se debe usar un proxy
    bool redirect = 4; // Permite o impide redirecciones automáticas
}
```

En el campo `session`, incluye el nombre de la sesión deseada, como `GoogleTranslateAPI` o `GoogleTranslateClient`. Esto permitirá que el servicio Proxy-API use las configuraciones específicas de esa sesión al realizar la solicitud.

## Conclusión

Con estas instrucciones avanzadas, deberías ser capaz de construir y ejecutar el servicio Proxy-API, tanto directamente como a través de Docker, y utilizar sus capacidades en otros proyectos mediante los archivos generados por `generateProxyProto.sh`. Además, puedes aprovechar las sesiones para realizar solicitudes personalizadas a diferentes servicios web.
----- [Archivo: script.sh] -----
#!/usr/bin/env bash

# Nombre del archivo de salida
OUTPUT="esquema.txt"

# Patrones a excluir (incluye el propio OUTPUT)
EXCLUDE_PATTERNS=(
  "$OUTPUT"        # No incluir el archivo de salida
  ".git"           # Control de versiones
  "node_modules"   # Dependencias de Node.js
  ".DS_Store"      # Metadatos en macOS
  "Thumbs.db"      # Metadatos en Windows
  "__pycache__"    # Cachés de Python
  "*.pyc"          # Archivos compilados de Python
  "*.o"            # Objetos compilados (C/C++)
  "*.so"           # Librerías compartidas
  "venv"           # Entorno virtual de Python
  "dist"           # Carpeta de distribución
  "fetch"         # Archivos de caché de fetch
  "proxyserver"         # Archivos de caché de fetch
  ".gitignore"    # Ignorar archivos de configuración de git
  "main"
)

# 1) Truncar o crear el archivo de salida sin preguntar
: > "$OUTPUT"

# 2) Construir la expresión de prune para find
prune_args=()
for pat in "${EXCLUDE_PATTERNS[@]}"; do
  prune_args+=( -name "$pat" -o )
done
# Eliminar el último '-o'
unset 'prune_args[${#prune_args[@]}-1]'

# 3) Estructura de directorios y archivos
echo "=== Estructura de directorios y archivos ===" >> "$OUTPUT"
find . -mindepth 1 \( "${prune_args[@]}" \) -prune -o -print | \
  sed \
    -e 's|[^/]*/|│   |g' \
    -e 's|│   \([^│]\)|├── \1|' \
  >> "$OUTPUT"
echo >> "$OUTPUT"

# 4) Contenido de cada archivo
echo "=== Contenido de archivos ===" >> "$OUTPUT"
find . -mindepth 1 \( "${prune_args[@]}" \) -prune -o \( -type f ! -name "$OUTPUT" -print \) | sort | \
while IFS= read -r file; do
  rel="${file#./}"
  echo "----- [Archivo: $rel] -----" >> "$OUTPUT"
  if [ -r "$file" ] && [ ! -d "$file" ]; then
    cat "$file" >> "$OUTPUT"
  else
    echo "[No se puede leer: $rel]" >> "$OUTPUT"
  fi
  echo >> "$OUTPUT"
done

