=== Estructura de directorios y archivos ===
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ api
‚îÇ   ‚îú‚îÄ‚îÄ server.go
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ script.sh
‚îú‚îÄ‚îÄ fix.sh
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ generateProxyProto.sh
‚îú‚îÄ‚îÄ internal
‚îÇ   ‚îú‚îÄ‚îÄ proxy
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ proxy.go
‚îÇ   ‚îú‚îÄ‚îÄ scraper
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scraper.go
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sessions.go
‚îú‚îÄ‚îÄ cmd
‚îÇ   ‚îú‚îÄ‚îÄ main.go

=== Contenido de archivos ===
----- [Archivo: api/server.go] -----
// api/server.go
package api

import (
	"context"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net"
	"net/http"
	"net/url"
	pb "proxy-api/fetch"
	"proxy-api/internal/config"
	"proxy-api/internal/proxy"
	"proxy-api/internal/scraper"
	"strings"
	"sync"
	"time"

	"google.golang.org/grpc"
)

var (
	validProxies map[string][]string
	userAgents   []string
)

type server struct {
	pb.UnimplementedProxyServiceServer
	successfulProxies map[string]*http.Client
	mtx               sync.RWMutex
}

var errorMap = map[string]struct{}{
	"context deadline exceeded (Client.Timeout or context cancellation while reading body)": {},
	"EOF":                       {},
	"read tcp":                  {},
	"connection":                {},
	"Timeout":                   {},
	"Forbidden":                 {},
	"(Client.Timeout":           {},
	"Internal Server Error":     {},
	"Bad Gateway":               {},
	"Service Unavailable":       {},
	"Gateway Timeout":           {},
	"Too many open connections": {},
	"unconfigured cipher suite": {},
	"ClientConn.Close":          {},
	"GOAWAY":                    {},
	"proxyconnect tcp:":         {},
	"Temporary Redirect":        {},
	"Internal Privoxy Error":    {},
	"certificate":               {},
	"bad record MAC":            {},
	"lookup":                    {},
}

func isTimeoutError(err error) bool {
	if urlErr, ok := err.(*url.Error); ok && urlErr.Timeout() {
		return true
	}

	for errMsg := range errorMap {
		if strings.Contains(err.Error(), errMsg) || err.Error() == errMsg {
			return true
		}
	}

	return false
}

var nilMap = map[string]struct{}{
	"<strong>Error:</strong>": {},
	"Marshal":                 {},
	"error while marshaling: proto: Marshal called with nilh": {},
	"Servicio no": {},
	"GOAWAY":      {},
	`http2: server sent GOAWAY and closed the connection;`:                      {},
	`{"code":110,"message":"Sport API error","name":"ServiceUnavailableError"}`: {},
	"http2:":          {},
	"temporary error": {},
}

func IsNilContent(content string) bool {
	for errMsg := range nilMap {
		if strings.Contains(content, errMsg) || content == errMsg {
			return true
		}
	}

	return false
}

func (s *server) getHTTPClient(proxyAddr string, redirect bool, session string) (*http.Client, error) {
	s.mtx.RLock()
	client, ok := s.successfulProxies[proxyAddr]
	s.mtx.RUnlock()

	if ok {
		return client, nil
	}

	if proxyAddr == "default" {
		return http.DefaultClient, nil
	}

	proxyURL, _ := url.Parse(proxyAddr)
	client = &http.Client{
		Transport: &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
		},
		Timeout: time.Duration(config.ProxySessions[session].Timeout) * time.Millisecond,
	}

	if !redirect {
		client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		}
	} else {
		client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
			return nil
		}
	}

	s.mtx.Lock()
	s.successfulProxies[proxyAddr] = client
	s.mtx.Unlock()

	return client, nil
}

func (s *server) removeSuccesfulProxy(proxyAddr string) {
	s.mtx.Lock()
	delete(s.successfulProxies, proxyAddr)
	s.mtx.Unlock()
}

// GetRandomProxy - Nuevo m√©todo para obtener un proxy aleatorio de una sesi√≥n espec√≠fica
func (s *server) GetRandomProxy(ctx context.Context, req *pb.ProxyRequest) (*pb.ProxyResponse, error) {
	if req.Session == "" {
		return nil, fmt.Errorf("session cannot be empty")
	}

	// Verificar si la sesi√≥n existe en la configuraci√≥n
	if _, exists := config.ProxySessions[req.Session]; !exists {
		return nil, fmt.Errorf("session '%s' not found in configuration", req.Session)
	}

	// Verificar si hay proxies v√°lidos para esta sesi√≥n
	proxies, exists := validProxies[req.Session]
	if !exists || len(proxies) == 0 {
		return &pb.ProxyResponse{
			Proxy:   "",
			Success: false,
			Message: fmt.Sprintf("no valid proxies available for session '%s'", req.Session),
		}, nil
	}

	// Seleccionar un proxy aleatorio
	randomIndex := rand.Intn(len(proxies))
	selectedProxy := proxies[randomIndex]

	log.Printf("Selected random proxy for session '%s': %s", req.Session, selectedProxy)

	return &pb.ProxyResponse{
		Proxy:   selectedProxy,
		Success: true,
		Message: fmt.Sprintf("proxy selected successfully for session '%s'", req.Session),
	}, nil
}

// GetProxyStats - M√©todo adicional para obtener estad√≠sticas de proxies por sesi√≥n
func (s *server) GetProxyStats(ctx context.Context, req *pb.StatsRequest) (*pb.StatsResponse, error) {
	stats := make(map[string]int32)
	
	for session, proxies := range validProxies {
		stats[session] = int32(len(proxies))
	}

	return &pb.StatsResponse{
		ProxyCountBySession: stats,
		TotalValidProxies:   int32(getTotalProxyCount()),
	}, nil
}

func getTotalProxyCount() int {
	total := 0
	for _, proxies := range validProxies {
		total += len(proxies)
	}
	return total
}

// WITHOUT PROXIES
func (s *server) Fetch(ctx context.Context, req *pb.Request, userAgent string, redirect bool) (*pb.Response, error) {
	client, err := s.getHTTPClient("default", redirect, req.Session)
	if err != nil {
		return nil, err
	}

	reqObj, err := http.NewRequestWithContext(ctx, "GET", req.Url, nil)
	if err != nil {
		return nil, err
	}

	reqObj.Header.Set("User-Agent", userAgent)
	for k, v := range config.GetHeadersFromSession(req.Session) {
		reqObj.Header.Set(k, v)
	}

	resp, err := client.Do(reqObj)
	if err != nil {
		// Retry if there is a timeout error.
		if ctx.Err() == context.DeadlineExceeded || isTimeoutError(err) {
			log.Println("Retry due to", err)
			return s.Fetch(ctx, req, userAgent, redirect)
		}

		return nil, err
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	log.Printf("User-Agent: %s, Status: %d, URL: %s\n", userAgent, resp.StatusCode, req.Url)
	return &pb.Response{Content: bodyBytes}, nil
}

func (s *server) useProxyToFetch(ctx context.Context, req *pb.Request, proxyAddr string, userAgent string, redirect bool, contentChan chan []byte, errorChan chan error) {
	client, err := s.getHTTPClient(proxyAddr, redirect, req.Session)
	if err != nil {
		errorChan <- err
		return
	}

	reqObj, err := http.NewRequestWithContext(ctx, "GET", req.Url, nil)
	if err != nil {
		errorChan <- err
		return
	}

	reqObj.Header.Set("User-Agent", userAgent)
	for k, v := range config.GetHeadersFromSession(req.Session) {
		reqObj.Header.Set(k, v)
	}

	resp, err := client.Do(reqObj)
	if err != nil {
		s.removeSuccesfulProxy(proxyAddr) // remove the proxy from successfulProxies
		errorChan <- err
		return
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		errorChan <- err
		return
	}

	log.Printf("Proxy: %s, User-Agent: %s, Status: %d, URL: %s", proxyAddr, userAgent, resp.StatusCode, req.Url)
	contentChan <- bodyBytes
}

func (s *server) FetchContent(ctx context.Context, req *pb.Request) (*pb.Response, error) {
	if req.Session == "" || validProxies[req.Session] == nil {
		return nil, fmt.Errorf("invalid session")
	}

	var redirect bool
	if req.Redirect {
		redirect = req.Redirect
	} else {
		redirect = false
	}

	selectedUserAgent := userAgents[rand.Intn(len(userAgents))]

	if req.Proxy {
		contentChan := make(chan []byte)
		errorChan := make(chan error)

		// Primero se utilizan los successfulProxies
		s.mtx.RLock()
		for proxyAddr := range s.successfulProxies {
			go s.useProxyToFetch(ctx, req, "http://"+proxyAddr, selectedUserAgent, redirect, contentChan, errorChan)
		}
		s.mtx.RUnlock()

		// Si falla, utiliza los validProxies
		if len(contentChan) == 0 {
			for _, proxyAddr := range validProxies[req.Session] {
				go s.useProxyToFetch(ctx, req, "http://"+proxyAddr, selectedUserAgent, redirect, contentChan, errorChan)
			}
		}

		for range validProxies[req.Session] {
			select {
			case content := <-contentChan:
				return &pb.Response{Content: content}, nil
			case <-errorChan:
				continue
			}
		}

		return s.Fetch(ctx, req, selectedUserAgent, redirect)
	}

	return s.Fetch(ctx, req, selectedUserAgent, redirect)
}

func UpdateValidProxies(proxies map[string][]string) {
	validProxies = proxies
}

func StartGRPCServer() {
	validProxies = proxy.GetValidProxies()
	userAgents = scraper.ScrapeUserAgents()

	log.Println("Iniciando servidor gRPC")
	lis, err := net.Listen("tcp", ":5000")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	maxSize := 5 * 1024 * 1024
	grpcServer := grpc.NewServer(
		grpc.MaxRecvMsgSize(maxSize), // Tama√±o m√°ximo de mensaje recibido.
		grpc.MaxSendMsgSize(maxSize), // Tama√±o m√°ximo de mensaje enviado.
	)
	pb.RegisterProxyServiceServer(grpcServer, &server{successfulProxies: make(map[string]*http.Client)})
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
----- [Archivo: cmd/main.go] -----
package main

import (
	"fmt"
	"proxy-api/api"
	"proxy-api/internal/config"
	"proxy-api/internal/proxy"
	"time"
)

func main() {
	// Iniciar el servidor gRPC
	go api.StartGRPCServer()

	// Refrescar proxies al inicio
	go reloadProxiesInBackground()

	// Mantener la aplicaci√≥n en ejecuci√≥n
	select {}
}

func reloadProxiesInBackground() {
	for {
		time.Sleep(config.UpdateTime * time.Minute)

		newProxyMap := proxy.GetValidProxies()
		fmt.Printf("Proxies v√°lidos refrescados: %d\n", len(newProxyMap))

		// Update the valid proxies in the server
		api.UpdateValidProxies(newProxyMap)
	}
}

----- [Archivo: docker-compose.yml] -----
version: "3.8"

services:
  api:
    build: .
    container_name: proxy_server
    ports:
      - "5000:5000"
    restart: always
    networks:
      - proxy_network

networks:
  proxy_network:
    driver: bridge
    name: proxy_network
    
----- [Archivo: Dockerfile] -----
# Usa una imagen de Go como base
FROM golang AS builder

# Configura las variables de entorno
ENV GO111MODULE=on \
    CGO_ENABLED=0 \
    GOOS=linux \
    GOARCH=amd64

# Crea un directorio de trabajo dentro del contenedor
WORKDIR /build

# Copia los archivos del proyecto al directorio de trabajo
COPY . .

# Compila la aplicaci√≥n
RUN go build -o main ./cmd/main.go

# Empieza a construir la imagen final
FROM alpine:latest

# Instala las dependencias necesarias
RUN apk --no-cache add ca-certificates

# Copia el binario compilado desde la etapa anterior
COPY --from=builder /build/main /app/main

# Establece el directorio de trabajo
WORKDIR /app

# Expone el puerto en el que la aplicaci√≥n escucha
EXPOSE 5000

# Ejecuta la aplicaci√≥n cuando el contenedor se inicia
CMD ["./main"]
----- [Archivo: fix.sh] -----
#!/usr/bin/env bash

# Script para resolver problemas de compatibilidad con gRPC
set -e

echo "=== Solucionando problemas de compatibilidad gRPC ==="

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Funci√≥n para imprimir mensajes coloreados
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 1. Verificar que Go est√° instalado
if ! command -v go &> /dev/null; then
    print_error "Go no est√° instalado. Por favor inst√°lalo desde https://golang.org/"
    exit 1
fi

print_status "Go versi√≥n: $(go version)"

# 2. Limpiar m√≥dulos y cach√©
print_status "Limpiando cach√© de m√≥dulos Go..."
go clean -modcache
go mod tidy

# 3. Actualizar dependencias
print_status "Actualizando dependencias..."
go get -u google.golang.org/grpc@latest
go get -u google.golang.org/protobuf@latest
go mod tidy

# 4. Instalar/actualizar herramientas de protoc
print_status "Instalando herramientas de Protocol Buffers..."

# Verificar si protoc est√° instalado
if ! command -v protoc &> /dev/null; then
    print_error "protoc no est√° instalado."
    echo "Por favor inst√°lalo:"
    echo "  - Ubuntu/Debian: sudo apt install protobuf-compiler"
    echo "  - macOS: brew install protobuf"
    echo "  - Windows: Descarga desde https://github.com/protocolbuffers/protobuf/releases"
    exit 1
fi

print_status "protoc versi√≥n: $(protoc --version)"

# Instalar plugins de Go para protoc
print_status "Instalando plugins de protoc para Go..."
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

# Verificar que los plugins est√°n en el PATH
if ! command -v protoc-gen-go &> /dev/null; then
    print_warning "protoc-gen-go no est√° en el PATH"
    echo "Aseg√∫rate de que \$GOPATH/bin est√° en tu PATH:"
    echo "export PATH=\$PATH:\$(go env GOPATH)/bin"
fi

if ! command -v protoc-gen-go-grpc &> /dev/null; then
    print_warning "protoc-gen-go-grpc no est√° en el PATH"
    echo "Aseg√∫rate de que \$GOPATH/bin est√° en tu PATH:"
    echo "export PATH=\$PATH:\$(go env GOPATH)/bin"
fi

# 5. Crear directorio fetch si no existe
mkdir -p fetch

# 6. Crear archivo proto actualizado
print_status "Creando archivo proto actualizado..."
cat > fetch/proxy.proto << 'EOF'
syntax = "proto3";

package fetch;

option go_package = "proxy-api/fetch";

// Servicio principal de proxy
service ProxyService {
    // M√©todo existente para obtener contenido
    rpc FetchContent(Request) returns (Response);
    
    // Nuevo m√©todo para obtener un proxy aleatorio
    rpc GetRandomProxy(ProxyRequest) returns (ProxyResponse);
    
    // M√©todo adicional para obtener estad√≠sticas de proxies
    rpc GetProxyStats(StatsRequest) returns (StatsResponse);
}

// Mensaje de solicitud existente
message Request {
    string url = 1;
    string session = 2;
    bool proxy = 3;
    bool redirect = 4;
}

// Mensaje de respuesta existente
message Response {
    bytes content = 1;
}

// Nuevo mensaje para solicitar un proxy aleatorio
message ProxyRequest {
    string session = 1; // Sesi√≥n para la cual obtener el proxy
}

// Nuevo mensaje de respuesta para proxy aleatorio
message ProxyResponse {
    string proxy = 1;   // Direcci√≥n del proxy (ip:port)
    bool success = 2;   // Indica si la operaci√≥n fue exitosa
    string message = 3; // Mensaje descriptivo del resultado
}

// Mensaje para solicitar estad√≠sticas
message StatsRequest {
    // Vac√≠o por ahora, podr√≠a expandirse en el futuro
}

// Mensaje de respuesta con estad√≠sticas
message StatsResponse {
    map<string, int32> proxy_count_by_session = 1; // Cantidad de proxies por sesi√≥n
    int32 total_valid_proxies = 2;                 // Total de proxies v√°lidos
}
EOF

# 7. Eliminar archivos proto generados anteriormente
print_status "Eliminando archivos proto generados anteriormente..."
rm -f fetch/*.pb.go

# 8. Generar nuevos archivos proto
print_status "Generando archivos proto..."
protoc \
    --proto_path=fetch \
    --go_out=fetch \
    --go_opt=paths=source_relative \
    --go-grpc_out=fetch \
    --go-grpc_opt=paths=source_relative \
    fetch/proxy.proto

# 9. Verificar que los archivos se generaron correctamente
if [ -f "fetch/proxy.pb.go" ] && [ -f "fetch/proxy_grpc.pb.go" ]; then
    print_status "‚úÖ Archivos proto generados exitosamente"
else
    print_error "‚ùå Error generando archivos proto"
    exit 1
fi

# 10. Intentar compilar el proyecto
print_status "Verificando compilaci√≥n del proyecto..."
if go build ./cmd/main.go; then
    print_status "‚úÖ Proyecto compilado exitosamente"
    rm -f main # Limpiar binario de prueba
else
    print_error "‚ùå Error compilando el proyecto"
    echo "Revisa los errores anteriores e intenta de nuevo"
    exit 1
fi

# 11. Mostrar informaci√≥n de las dependencias
print_status "Informaci√≥n de dependencias actuales:"
go list -m all | grep -E "(grpc|protobuf)"

echo ""
print_status "üéâ ¬°Problema resuelto! El proyecto deber√≠a compilar correctamente ahora."
echo ""
echo "Pr√≥ximos pasos:"
echo "1. go build ./cmd/main.go"
echo "2. ./main"
echo "3. go run client/main.go (en otra terminal)"
----- [Archivo: generateProxyProto.sh] -----
#!/usr/bin/env bash

# Script para generar archivos gRPC desde el archivo proto
# Aseg√∫rate de tener instalados:
# - protoc (Protocol Buffers compiler)
# - protoc-gen-go (Go plugin para protoc)
# - protoc-gen-go-grpc (gRPC Go plugin)

set -e

echo "=== Generando archivos gRPC desde proxy_service.proto ==="

# Directorio donde est√° el archivo proto
PROTO_DIR="fetch/"
# Directorio de salida para los archivos generados
OUT_DIR="fetch/"

# Crear directorio de salida si no existe
mkdir -p "$OUT_DIR"

# Verificar que existe el archivo proto
if [ ! -f "$PROTO_DIR/proxy_service.proto" ]; then
    echo "Error: No se encontr√≥ el archivo proxy_service.proto en $PROTO_DIR"
    echo "Por favor aseg√∫rate de que el archivo proto existe."
    exit 1
fi

# Verificar que protoc est√° instalado
if ! command -v protoc &> /dev/null; then
    echo "Error: protoc no est√° instalado."
    echo "Inst√°lalo desde: https://grpc.io/docs/protoc-installation/"
    exit 1
fi

# Verificar que los plugins de Go est√°n instalados
if ! command -v protoc-gen-go &> /dev/null; then
    echo "Error: protoc-gen-go no est√° instalado."
    echo "Inst√°lalo con: go install google.golang.org/protobuf/cmd/protoc-gen-go@latest"
    exit 1
fi

if ! command -v protoc-gen-go-grpc &> /dev/null; then
    echo "Error: protoc-gen-go-grpc no est√° instalado."
    echo "Inst√°lalo con: go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest"
    exit 1
fi

echo "Generando archivos Go desde proxy_service.proto..."

# Generar archivos Go
protoc \
    --proto_path="$PROTO_DIR" \
    --go_out="$OUT_DIR" \
    --go_opt=paths=source_relative \
    --go-grpc_out="$OUT_DIR" \
    --go-grpc_opt=paths=source_relative \
    "$PROTO_DIR/proxy_service.proto"

echo "‚úÖ Archivos Go generados exitosamente en $OUT_DIR"

# Opcional: Generar para otros lenguajes
read -p "¬øQuieres generar tambi√©n archivos para Python? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    PYTHON_OUT="./generated/python"
    mkdir -p "$PYTHON_OUT"
    
    if command -v python3 &> /dev/null && python3 -c "import grpc_tools" &> /dev/null; then
        echo "Generando archivos Python..."
        python3 -m grpc_tools.protoc \
            --proto_path="$PROTO_DIR" \
            --python_out="$PYTHON_OUT" \
            --grpc_python_out="$PYTHON_OUT" \
            "$PROTO_DIR/proxy_service.proto"
        echo "‚úÖ Archivos Python generados en $PYTHON_OUT"
    else
        echo "‚ùå Python3 o grpc_tools no est√°n disponibles"
        echo "Instala con: pip install grpcio-tools"
    fi
fi

read -p "¬øQuieres generar tambi√©n archivos para JavaScript/TypeScript? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    JS_OUT="./generated/javascript"
    mkdir -p "$JS_OUT"
    
    if command -v npm &> /dev/null; then
        echo "Generando archivos JavaScript..."
        protoc \
            --proto_path="$PROTO_DIR" \
            --js_out=import_style=commonjs,binary:"$JS_OUT" \
            --grpc-web_out=import_style=commonjs,mode=grpcwebtext:"$JS_OUT" \
            "$PROTO_DIR/proxy_service.proto"
        echo "‚úÖ Archivos JavaScript generados en $JS_OUT"
    else
        echo "‚ùå npm no est√° disponible"
    fi
fi

echo ""
echo "=== Generaci√≥n completada ==="
echo "Archivos principales generados:"
echo "  - $OUT_DIR/proxy.pb.go (mensajes Protocol Buffers)"
echo "  - $OUT_DIR/proxy_grpc.pb.go (servicio gRPC)"
echo ""
echo "Para usar estos archivos en tu proyecto Go:"
echo "  import fetch \"proxy-api/fetch\""
echo ""
echo "Para recompilar el proyecto:"
echo "  go build ./cmd/main.go"
----- [Archivo: go.mod] -----
module proxy-api

go 1.23.0

toolchain go1.23.12

require (
	google.golang.org/grpc v1.74.2
	google.golang.org/protobuf v1.36.7
)

require (
	golang.org/x/net v0.42.0 // indirect
	golang.org/x/sys v0.35.0 // indirect
	golang.org/x/text v0.28.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b // indirect
)

----- [Archivo: go.sum] -----
github.com/go-logr/logr v1.4.3 h1:CjnDlHq8ikf6E492q6eKboGOC0T8CDaOvkHCIg8idEI=
github.com/go-logr/logr v1.4.3/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
go.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJySYA=
go.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=
go.opentelemetry.io/otel v1.36.0 h1:UumtzIklRBY6cI/lllNZlALOF5nNIzJVb16APdvgTXg=
go.opentelemetry.io/otel v1.36.0/go.mod h1:/TcFMXYjyRNh8khOAO9ybYkqaDBb/70aVwkNML4pP8E=
go.opentelemetry.io/otel/metric v1.36.0 h1:MoWPKVhQvJ+eeXWHFBOPoBOi20jh6Iq2CcCREuTYufE=
go.opentelemetry.io/otel/metric v1.36.0/go.mod h1:zC7Ks+yeyJt4xig9DEw9kuUFe5C3zLbVjV2PzT6qzbs=
go.opentelemetry.io/otel/sdk v1.36.0 h1:b6SYIuLRs88ztox4EyrvRti80uXIFy+Sqzoh9kFULbs=
go.opentelemetry.io/otel/sdk v1.36.0/go.mod h1:+lC+mTgD+MUWfjJubi2vvXWcVxyr9rmlshZni72pXeY=
go.opentelemetry.io/otel/sdk/metric v1.36.0 h1:r0ntwwGosWGaa0CrSt8cuNuTcccMXERFwHX4dThiPis=
go.opentelemetry.io/otel/sdk/metric v1.36.0/go.mod h1:qTNOhFDfKRwX0yXOqJYegL5WRaW376QbB7P4Pb0qva4=
go.opentelemetry.io/otel/trace v1.36.0 h1:ahxWNuqZjpdiFAyrIoQ4GIiAIhxAunQR6MUoKrsNd4w=
go.opentelemetry.io/otel/trace v1.36.0/go.mod h1:gQ+OnDZzrybY4k4seLzPAWNwVBBVlF2szhehOBB/tGA=
golang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=
golang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=
golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=
golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/text v0.28.0 h1:rhazDwis8INMIwQ4tpjLDzUhx6RlXqZNPEM0huQojng=
golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b h1:zPKJod4w6F1+nRGDI9ubnXYhU9NSWoFAijkHkUXeTK8=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b/go.mod h1:qQ0YXyHHx3XkvlzUtpXDkS29lDSafHMZBAZDc03LQ3A=
google.golang.org/grpc v1.74.2 h1:WoosgB65DlWVC9FqI82dGsZhWFNBSLjQ84bjROOpMu4=
google.golang.org/grpc v1.74.2/go.mod h1:CtQ+BGjaAIXHs/5YS3i473GqwBBa1zGQNevxdeBEXrM=
google.golang.org/protobuf v1.36.7 h1:IgrO7UwFQGJdRNXH/sQux4R1Dj1WAKcLElzeeRaXV2A=
google.golang.org/protobuf v1.36.7/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=

----- [Archivo: internal/config/config.go] -----
package config

// Tama√±o del chunk de proxies
const DefaultChunkSize = 20
const DefaultSessionTimeout = 2000 //ms
const UpdateTime = 30

----- [Archivo: internal/config/sessions.go] -----
package config

type ProxySession struct {
	Name    string
	URL     string
	Headers map[string]string
	Timeout int
}

var ProxySessions = map[string]ProxySession{
	/*"FlashScore": {
		Name: "FlashScore",
		URL:  "https://local-global.flashscore.ninja/2/x/feed/r_1_1",
		Headers: map[string]string{
			"Accept-Encoding":    "gzip, deflate, br",
			"Accept-Language":    "es-ES,es;q=0.9,en;q=0.8,zh-TW;q=0.7,zh;q=0.6,ja;q=0.5,zh-CN;q=0.4",
			"Origin":             "https://www.flashscore.es",
			"Referer":            "https://www.flashscore.es/",
			"Sec-Ch-Ua":          "'Google Chrome';v='117', 'Not;A=Brand';v='8', 'Chromium';v='117'",
			"Sec-Ch-Ua-Mobile":   "?0",
			"Sec-Ch-Ua-Platform": "'Windows'",
			"Sec-Fetch-Dest":     "empty",
			"Sec-Fetch-Mode":     "cors",
			"Sec-Fetch-Site":     "cross-site",
			"X-Fsign":            "SW9D1eZo",
		},
		Timeout: DefaultSessionTimeout,
	}, */
	"CoinMarketCap": {
		Name:    "CoinMarketCap",
		URL:     "https://coinmarketcap.com/es/",
		Headers: map[string]string{},
		Timeout: DefaultSessionTimeout,
	},
}

func GetHeadersFromSession(session string) map[string]string {
	return ProxySessions[session].Headers
}

----- [Archivo: internal/proxy/proxy.go] -----
package proxy

import (
	"log"
	"net/http"
	"net/url"
	"proxy-api/internal/config"
	"proxy-api/internal/scraper"
	"sync"
	"time"
)

// Tama√±o del chunk, idealmente esto deber√≠a venir de un archivo de configuraci√≥n
const ChunkSize = config.DefaultChunkSize

// ValidProxies almacena los proxies v√°lidos, con locking para acceso seguro
var (
	ValidProxies = make(map[string][]string)
	mutex        = &sync.Mutex{}
)

// Procesar un solo test de proxy
func RunProxyTest(cfg config.ProxySession, proxy string) {
	proxyURL, err := url.Parse("http://" + proxy)
	if err != nil {
		log.Printf("Error al parsear el proxy %s: %v", proxy, err)
		return
	}

	httpClient := &http.Client{
		Transport: &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
		},
		Timeout: time.Duration(cfg.Timeout) * time.Millisecond,
	}

	request, err := http.NewRequest("GET", cfg.URL, nil)
	if err != nil {
		log.Printf("Error al crear la solicitud: %v", err)
		return
	}

	for headerName, headerValue := range cfg.Headers {
		request.Header.Set(headerName, headerValue)
	}

	request.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36")

	resp, err := httpClient.Do(request)
	if err != nil || (resp != nil && resp.StatusCode != 200) {
		log.Printf("Proxy %s no v√°lido para %s", proxy, cfg.Name)
		if resp != nil {
			resp.Body.Close()
		}
		return
	}

	mutex.Lock()
	ValidProxies[cfg.Name] = append(ValidProxies[cfg.Name], proxy)
	mutex.Unlock()

	if resp != nil {
		resp.Body.Close()
	}
}

// Procesar todos los tests en un proxy
func runAllTests(proxy string) {
	var wg sync.WaitGroup
	wg.Add(len(config.ProxySessions))

	for _, test := range config.ProxySessions {
		go func(test config.ProxySession) {
			defer wg.Done()
			RunProxyTest(test, proxy)
		}(test)
	}

	wg.Wait()
}

// Divide los proxies en chunks m√°s manejables
func chunkProxies(proxies []string) [][]string {
	var chunks [][]string
	for i := 0; i < len(proxies); i += ChunkSize {
		end := i + ChunkSize
		if end > len(proxies) {
			end = len(proxies)
		}
		chunks = append(chunks, proxies[i:end])
	}
	return chunks
}

// ValidateProxies realiza la validaci√≥n de la lista de proxies
func GetValidProxies() map[string][]string {
	proxies := scraper.ScrapeProxies()
	chunks := chunkProxies(proxies)
	var wg sync.WaitGroup
	var progressMutex sync.Mutex
	chunksProcessed := 0

	for _, chunk := range chunks {
		wg.Add(1)
		go func(chunk []string) {
			defer wg.Done()
			for _, proxy := range chunk {
				runAllTests(proxy)
			}

			progressMutex.Lock()
			chunksProcessed++
			log.Printf("Progreso: %d/%d chunks procesados.", chunksProcessed, len(chunks))
			progressMutex.Unlock()

		}(chunk)
	}

	wg.Wait()

	mutex.Lock()
	defer mutex.Unlock()
	for site, proxies := range ValidProxies {
		log.Printf("Sitio web: %s | Proxies: %v", site, len(proxies))
	}

	return ValidProxies
}

----- [Archivo: internal/scraper/scraper.go] -----
package scraper

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

type Scraper struct {
	urls     []string
	dataType string
}

func NewScraper(urls []string, dataType string) *Scraper {
	return &Scraper{
		urls:     urls,
		dataType: dataType,
	}
}

func (s *Scraper) Scrape(ctx context.Context) []string {
	resultChan := make(chan []string)
	errChan := make(chan error)

	for _, url := range s.urls {
		go s.fetchData(ctx, url, resultChan, errChan)
	}

	timeout := time.After(25 * time.Second)
	var results []string
	for i := 0; i < len(s.urls); i++ {
		select {
		case res := <-resultChan:
			results = append(results, res...)
		case err := <-errChan:
			fmt.Printf("Error scraping %s data: %s\n", s.dataType, err)
		case <-timeout:
			fmt.Println("Scraping timed out.")
			return results
		}
	}
	return results
}

func (s *Scraper) fetchData(ctx context.Context, url string, resultChan chan []string, errChan chan error) {
	fmt.Printf("Obteniendo %s de %s...\n", s.dataType, url)

	req, _ := http.NewRequest(http.MethodGet, url, nil)
	resp, err := http.DefaultClient.Do(req.WithContext(ctx))
	if err != nil {
		errChan <- err
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		errChan <- err
		return
	}

	lines := strings.Split(string(body), "\n")
	var validLines []string
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.Count(trimmed, ":") > 1 {
			trimmed = strings.Split(trimmed, ":")[0] + ":" + strings.Split(trimmed, ":")[1]
		}
		if trimmed != "" || (strings.Contains(url, "user-agents") && (!strings.Contains(trimmed, "Android") &&
			!strings.Contains(trimmed, "iPhone") &&
			!strings.Contains(trimmed, "iPad") &&
			!strings.Contains(trimmed, "compatible;"))) {

			validLines = append(validLines, trimmed)
		}
	}
	resultChan <- validLines
}

func ScrapeProxies() []string {
	urls := []string{
		// "https://raw.githubusercontent.com/proxifly/free-proxy-list/main/proxies/protocols/http/data.txt",
		// "https://raw.githubusercontent.com/proxifly/free-proxy-list/refs/heads/main/proxies/all/data.txt",
		"https://raw.githubusercontent.com/officialputuid/KangProxy/refs/heads/KangProxy/https/https.txt",
		"https://raw.githubusercontent.com/vakhov/fresh-proxy-list/refs/heads/master/https.txt",
		// "https://raw.githubusercontent.com/prxchk/proxy-list/main/http.txt",
		// "https://raw.githubusercontent.com/proxifly/free-proxy-list/main/proxies/protocols/http/data.txt",
		// "https://raw.githubusercontent.com/vakhov/fresh-proxy-list/master/http.txt",
		// "https://raw.githubusercontent.com/MuRongPIG/Proxy-Master/main/http.txt",
		// "https://raw.githubusercontent.com/ProxyScraper/ProxyScraper/main/http.txt",
	}
	scraper := NewScraper(urls, "proxies")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	return scraper.Scrape(ctx)
}

func ScrapeUserAgents() []string {
	urls := []string{
		"https://gist.githubusercontent.com/pzb/b4b6f57144aea7827ae4/raw/cf847b76a142955b1410c8bcef3aabe221a63db1/user-agents.txt",
	}
	scraper := NewScraper(urls, "user-agents")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// N√∫mero m√°ximo de intentos
	maxRetries := 3

	for attempt := 1; attempt <= maxRetries; attempt++ {
		result := scraper.Scrape(ctx)
		if len(result) > 0 {
			// Si la operaci√≥n tiene √©xito, retornar los datos
			return result
		}

		// Si la operaci√≥n falla, esperar un momento antes de volver a intentar
		fmt.Printf("Intento %d fallido. Reintentando...\n", attempt)
		scraper = NewScraper(urls, "user-agents")
		time.Sleep(2 * time.Second)
	}

	// Si todos los intentos fallan, retornar una lista vac√≠a o manejar el error de otra manera.
	return []string{}
}

----- [Archivo: README.md] -----
# Instrucciones Avanzadas para el Uso del Proyecto Proxy-API

## Montaje de la Imagen Docker en Segundo Plano

Adem√°s del uso de `docker-compose`, puedes construir y ejecutar la imagen Docker manualmente.

### Construir la Imagen con Docker Build

1. **Construye la imagen Docker:**
   ```sh
   docker build -t proxy-api .
   ```

   Esto crear√° una imagen Docker llamada `proxy-api` utilizando el `Dockerfile` presente en el proyecto.

2. **Ejecutar la imagen en segundo plano:**
   ```sh
   docker run -d -p 5000:5000 --name proxy_server proxy-api
   ```

   Este comando ejecutar√° un contenedor basado en la imagen `proxy-api`, exponiendo el puerto 5000 y ejecut√°ndose en segundo plano.

## Uso de los Archivos Proto en Otros Proyectos

Para generar los archivos necesarios para utilizar el servicio gRPC en otros proyectos:

1. **Ejecuta el script `generateProxyProto.sh`:**
   ```sh
   ./generateProxyProto.sh
   ```

   Esto generar√° los archivos necesarios en los lenguajes especificados (por ejemplo, Go, Python, etc.) a partir del archivo `proto`.

2. **Importa los archivos generados en tu proyecto cliente:**
   Utiliza estos archivos en tu proyecto cliente para interactuar con el servicio gRPC del Proxy-API.

## Sesiones y su Uso

Las sesiones en `config.ProxySessions` permiten especificar configuraciones particulares para diferentes destinos web. Cada sesi√≥n define un conjunto de encabezados HTTP, una URL y un tiempo de espera. Estas sesiones permiten adaptar las solicitudes a las particularidades de cada recurso web, como diferentes mecanismos de autenticaci√≥n o requerimientos de encabezados espec√≠ficos.

### Ejemplo de Sesiones

```go
var ProxySessions = map[string]ProxySession{
	"GoogleTranslateAPI": {
		Name:    "GoogleTranslateAPI",
		URL:     "https://translate.googleapis.com/translate_a/single...",
		Headers: map[string]string{},
		Timeout: DefaultSessionTimeout,
	},
	"GoogleTranslateClient": {
		Name:    "GoogleTranslateClient",
		URL:     "https://clients5.google.com/translate_a/t...",
		Headers: map[string]string{},
		Timeout: DefaultSessionTimeout,
	},
}
```

### Uso en el Servicio gRPC

Al realizar una solicitud a trav√©s del servicio `FetchContent` de gRPC, puedes especificar una de estas sesiones. El servidor Proxy-API utilizar√° la configuraci√≥n de la sesi√≥n elegida para personalizar la solicitud HTTP.

#### Ejemplo de Uso de Sesiones en una Solicitud gRPC

```proto
message Request {
    string url = 1; // URL a acceder
    string session = 2; // Nombre de la sesi√≥n a utilizar
    bool proxy = 3; // Indica si se debe usar un proxy
    bool redirect = 4; // Permite o impide redirecciones autom√°ticas
}
```

En el campo `session`, incluye el nombre de la sesi√≥n deseada, como `GoogleTranslateAPI` o `GoogleTranslateClient`. Esto permitir√° que el servicio Proxy-API use las configuraciones espec√≠ficas de esa sesi√≥n al realizar la solicitud.

## Conclusi√≥n

Con estas instrucciones avanzadas, deber√≠as ser capaz de construir y ejecutar el servicio Proxy-API, tanto directamente como a trav√©s de Docker, y utilizar sus capacidades en otros proyectos mediante los archivos generados por `generateProxyProto.sh`. Adem√°s, puedes aprovechar las sesiones para realizar solicitudes personalizadas a diferentes servicios web.
----- [Archivo: script.sh] -----
#!/usr/bin/env bash

# Nombre del archivo de salida
OUTPUT="esquema.txt"

# Patrones a excluir (incluye el propio OUTPUT)
EXCLUDE_PATTERNS=(
  "$OUTPUT"        # No incluir el archivo de salida
  ".git"           # Control de versiones
  "node_modules"   # Dependencias de Node.js
  ".DS_Store"      # Metadatos en macOS
  "Thumbs.db"      # Metadatos en Windows
  "__pycache__"    # Cach√©s de Python
  "*.pyc"          # Archivos compilados de Python
  "*.o"            # Objetos compilados (C/C++)
  "*.so"           # Librer√≠as compartidas
  "venv"           # Entorno virtual de Python
  "dist"           # Carpeta de distribuci√≥n
  "fetch"         # Archivos de cach√© de fetch
  "proxyserver"         # Archivos de cach√© de fetch
  ".gitignore"    # Ignorar archivos de configuraci√≥n de git
  "main"
)

# 1) Truncar o crear el archivo de salida sin preguntar
: > "$OUTPUT"

# 2) Construir la expresi√≥n de prune para find
prune_args=()
for pat in "${EXCLUDE_PATTERNS[@]}"; do
  prune_args+=( -name "$pat" -o )
done
# Eliminar el √∫ltimo '-o'
unset 'prune_args[${#prune_args[@]}-1]'

# 3) Estructura de directorios y archivos
echo "=== Estructura de directorios y archivos ===" >> "$OUTPUT"
find . -mindepth 1 \( "${prune_args[@]}" \) -prune -o -print | \
  sed \
    -e 's|[^/]*/|‚îÇ   |g' \
    -e 's|‚îÇ   \([^‚îÇ]\)|‚îú‚îÄ‚îÄ \1|' \
  >> "$OUTPUT"
echo >> "$OUTPUT"

# 4) Contenido de cada archivo
echo "=== Contenido de archivos ===" >> "$OUTPUT"
find . -mindepth 1 \( "${prune_args[@]}" \) -prune -o \( -type f ! -name "$OUTPUT" -print \) | sort | \
while IFS= read -r file; do
  rel="${file#./}"
  echo "----- [Archivo: $rel] -----" >> "$OUTPUT"
  if [ -r "$file" ] && [ ! -d "$file" ]; then
    cat "$file" >> "$OUTPUT"
  else
    echo "[No se puede leer: $rel]" >> "$OUTPUT"
  fi
  echo >> "$OUTPUT"
done

